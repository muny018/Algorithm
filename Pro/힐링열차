#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <vector>
#include <set>
#include <unordered_map>
using namespace std;

int nPeopleNum;
int nPeopleTrainNum;
int nTrainNum;

struct SortCmp
{
	bool operator() (const pair<long long, int> Left, const pair<long long, int> Right) const
	{
		if (Left.first > Right.first) return true;
		if (Left.first < Right.first) return false;

		if (Left.second < Right.second) return true;
		if (Left.second > Right.second) return false;

		return false;
	}
};



struct Info
{
	int Id;
	int JobID;
	long long nPoint;
	int nTrain;
};

unordered_map <int, Info> PeopleMap;			 // Key : ID, Value : 신상정보
unordered_map <int, vector<int>> JobMap;		 // Key : JobID, Value : id 모음집
vector <set <pair<long long, int>, SortCmp>>  TrainSet; // Point, ID 

void Init(int N, int M, int J, int nPoint[], int nJobID[])
{
	nPeopleNum = N;
	nPeopleTrainNum = M;
	nTrainNum = N / M;

	PeopleMap = unordered_map <int, Info>(N);
	JobMap = unordered_map <int, vector<int>>(J);
	TrainSet = vector <set <pair<long long, int>, SortCmp>>(nTrainNum);

	Info InputInfo;
	for (int i = 0; i < N; i++)
	{
		//승객정보
		InputInfo.Id = i;
		InputInfo.JobID = nJobID[i];
		InputInfo.nPoint = nPoint[i];
		InputInfo.nTrain = i / M;
		
		//신상정보 Map 넣기
		PeopleMap[i] = InputInfo;

		//Job 정보 Map 넣기
		JobMap[nJobID[i]].push_back(i);

		//Train 정보에 {포인트, id} 정보 넣기
		TrainSet[InputInfo.nTrain].insert({nPoint[i] ,  i});
	}
}

int Update(int mId, int mPoint)
{
	// 최대실행 10000번
	// mID를 지닌 승객의 포인트를 mPoint 만큼 더함
	// 최소 최대 + -10 ^ 9까지 가능
	// return mID 승객 포인트 반환

	auto it = PeopleMap.find(mId);
	
	int nBeforePoint = 0;
	int nAfterPoint = 0;
	int nTrainId = -1;

	//PeopleMap 신상정보 업데이트
	if (it != PeopleMap.end())
	{
		nBeforePoint = (*it).second.nPoint;
		nTrainId = (*it).second.nTrain;

		(*it).second.nPoint += mPoint;
		nAfterPoint = (*it).second.nPoint;
	}

	//TrainSet 기차에 있는 데이터 신상정보 업데이트
	auto TrainIt = TrainSet[nTrainId].find({ nBeforePoint,mId });
	
	if (TrainIt != TrainSet[nTrainId].end())
	{
		//Set 자료구조는 element들 수정이 불가능하여 데이터 수정을 위해 삽입, 삭제 진행함.
		//이 부분에서 Tact 소비가 심했지않나 생각됨.
		TrainSet[nTrainId].insert({ nAfterPoint, mId });
		TrainSet[nTrainId].erase(TrainIt);
	}

	return nAfterPoint;
}


int UpdateJob(int mJob, int mPoint)
{
	// 최대실행 300번
	// mJob 직업 ID를 가진 승객들의 Point를 mPoint만큼 추가
	// return Mjob직업을 가진 승객들의 Point 합

	long long nSum = 0;

	int nBeforePoint = 0;
	int nAfterPoint = 0;
	int nTrainId = -1;
	int nPeopleId = 0;

	auto JobIt = JobMap.find(mJob);

	if (JobIt != JobMap.end())
	{
		int nVecSize = (*JobIt).second.size();
		
		for (int i = 0; i < nVecSize; i++)
		{
			nPeopleId = (*JobIt).second.at(i);

			//위 Update 함수와 동일, ID값 찾아서 신상정보 업데이트하고 기차에 들어있는 신상정보 업뎃함
			auto PeopleIt = PeopleMap.find(nPeopleId);

			int nBeforePoint = 0;
			int nAfterPoint = 0;
			int nTrainId = -1;

			//PeopleMap 신상정보 업데이트
			if (PeopleIt != PeopleMap.end())
			{
				nBeforePoint = (*PeopleIt).second.nPoint;
				nTrainId = (*PeopleIt).second.nTrain;

				(*PeopleIt).second.nPoint += mPoint;
				nAfterPoint = (*PeopleIt).second.nPoint;
			}

			nSum += nAfterPoint;

			//TrainSet 기차에 있는 데이터 신상정보 업데이트
			auto TrainIt = TrainSet[nTrainId].find({ nBeforePoint, nPeopleId });

			if (TrainIt != TrainSet[nTrainId].end())
			{
				//Set 자료구조는 element들 수정이 불가능하여 데이터 수정을 위해 삽입, 삭제 진행함.
				//이 부분에서 Tact 소비가 심했지않나 생각됨.
				TrainSet[nTrainId].insert({ nAfterPoint, nPeopleId });
				TrainSet[nTrainId].erase(TrainIt);
			}
		}
	}

	return nSum;
}

int Move(int mNum)
{
	/*
		최대실행 1000
		2 * mNum <= M
		각 칸마다 Point별로 우선순위를 매겨서 상위 mNum 명 하위 mNum명씩 선정
		이 때 동일 Point면 작은 ID인 사람이 우선순위
		각 칸의 하위 mNum명과 그 다음칸 mNum명을 바꾼다.
		제일 앞칸은 앞칸이 없으니 상위 mNum 선정X
		마찬가지로 제일 마지막칸은 다음칸이 없으니 하위 mNum 선정X

		EX) 1번칸 하위 mNum명 < -> 2번째칸 상위 mNum명 Swap
		꼬리칸까지 계속 Swap 발생함.

		return 값 뭐해야했는지 기억안남.. 
	*/

	//기차에 옮길 element 담는 그릇 이차원 벡터 
	//Row : 기차idx   Col : 해당열차에 옮길 element
	vector< vector <pair<long long, int>>> MoveVec;  
	MoveVec = vector< vector <pair<long long, int>>>(nTrainNum);
	int nCount = 0;

	//검색
	for (int TrainIdx = 0; TrainIdx < nTrainNum; TrainIdx++)
	{
		nCount = mNum;

		//머리칸
		if (TrainIdx == 0)
		{
			while (nCount--)
			{
				auto it = TrainSet[TrainIdx].rbegin();
				MoveVec[TrainIdx+1].push_back((*it));
				TrainSet[TrainIdx].erase(*it);
			}
		}
		else if (TrainIdx == nTrainNum - 1) //꼬리칸
		{
			while (nCount--)
			{
				auto it = TrainSet[TrainIdx].begin();
				MoveVec[TrainIdx - 1].push_back((*it));
				TrainSet[TrainIdx].erase(it);
			}
		}
		else //중간칸
		{
			//상위권
			while (nCount--)
			{
				auto its = TrainSet[TrainIdx].begin();
				MoveVec[TrainIdx - 1].push_back((*its));
				TrainSet[TrainIdx].erase(its);
			}

			nCount = mNum;

			//하위권
			while (nCount--)
			{
				auto it = TrainSet[TrainIdx].rbegin();
				MoveVec[TrainIdx + 1].push_back((*it));
				TrainSet[TrainIdx].erase(*it);
			}			
		}
	}

	int nVecSize = 0;
	//옮겨주기
	for (int TrainIdx = 0; TrainIdx < nTrainNum; TrainIdx++)
	{
		nVecSize = MoveVec[TrainIdx].size();

		for (int i = 0; i < nVecSize; i++)
		{
			TrainSet[TrainIdx].insert(MoveVec[TrainIdx].at(i));
		}
	}

	return 0;
}

int main()
{
	return 0;
}
